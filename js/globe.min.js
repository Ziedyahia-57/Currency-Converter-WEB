const scene=new THREE.Scene;scene.background=null;const container=document.querySelector(".second"),width=container.clientWidth,height=container.clientHeight,camera=new THREE.PerspectiveCamera(60,width/height,.1,1e3);camera.position.z=1.75;const renderer=new THREE.WebGLRenderer({antialias:!0,alpha:!0,powerPreference:"high-performance"});renderer.outputEncoding=THREE.sRGBEncoding,renderer.setSize(width,height),container.innerHTML="";const canvas=renderer.domElement;canvas.style.display="block",canvas.style.width="100%",canvas.style.height="auto",canvas.style.maxWidth="100%",container.appendChild(canvas);const loadSvgTexture=()=>new Promise(e=>{let a=new Image;a.crossOrigin="anonymous",a.onload=()=>{let n=document.createElement("canvas");n.width=2048,n.height=1024;let t=n.getContext("2d");t.drawImage(a,0,0,n.width,n.height);let r=new THREE.CanvasTexture(n);r.encoding=THREE.sRGBEncoding,r.anisotropy=renderer.capabilities.getMaxAnisotropy(),e(r)},a.src="img/map-final.svg"});loadSvgTexture().then(e=>{let a=new THREE.ShaderMaterial({uniforms:{outerColor:{value:new THREE.Color(44683)},innerColor:{value:new THREE.Color(8947848)},opacity:{value:.8},backOpacity:{value:.2},map:{value:e}},vertexShader:`
        varying vec3 vNormal;
        varying vec2 vUv;
        varying float vFacingRatio;
        
        void main() {
          vNormal = normalize(normalMatrix * normal);
          vUv = uv;
          vec3 viewDirection = vec3(0.0, 0.0, 1.0);
          vFacingRatio = max(0.0, dot(vNormal, viewDirection));
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,fragmentShader:`
        uniform vec3 outerColor;
        uniform vec3 innerColor;
        uniform float opacity;
        uniform float backOpacity;
        uniform sampler2D map;
        varying vec3 vNormal;
        varying vec2 vUv;
        varying float vFacingRatio;
        
        void main() {
          float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
          vec3 gradient = mix(innerColor, outerColor, 1.0 - intensity);
          vec4 texColor = texture2D(map, vUv);
          vec3 finalColor = mix(gradient, texColor.rgb, texColor.a);
          float facingFactor = smoothstep(0.0, 0.5, vFacingRatio);
          float finalOpacity = mix(backOpacity, opacity, facingFactor) * texColor.a;
          gl_FragColor = vec4(finalColor, finalOpacity);
        }
      `,transparent:!0,side:THREE.DoubleSide}),n=new THREE.Mesh(new THREE.SphereGeometry(.85,128,128),a);n.rotation.y=-120*(Math.PI/180),scene.add(n);let t=new THREE.Mesh(new THREE.SphereGeometry(.86,128,128),new THREE.MeshBasicMaterial({color:44683,transparent:!0,opacity:.15,side:THREE.BackSide}));scene.add(t),scene.add(new THREE.AmbientLight(16777215,.3));let r=new THREE.OrbitControls(camera,canvas);r.enableDamping=!0,r.dampingFactor=.05,r.rotateSpeed=.4,r.autoRotate=!0,r.autoRotateSpeed=.5,r.enableZoom=!1,r.enablePan=!1,r.minPolarAngle=Math.PI/6,r.maxPolarAngle=5*Math.PI/6,r.screenSpacePanning=!1,r.maxDistance=1.75,r.minDistance=1.75;let o=()=>{requestAnimationFrame(o),r.update(),renderer.render(scene,camera)};o();let i=new ResizeObserver(()=>{let e=container.clientWidth,a=container.clientHeight;renderer.setSize(e,a),camera.aspect=e/a,camera.updateProjectionMatrix()});i.observe(container),canvas.style.cursor="grab",canvas.addEventListener("mousedown",()=>{canvas.style.cursor="grabbing",r.autoRotate=!1}),canvas.addEventListener("mouseup",()=>{canvas.style.cursor="grab",r.autoRotate=!0}),canvas.addEventListener("mouseleave",()=>{canvas.style.cursor="grab",r.autoRotate=!0})}).catch(e=>{console.error("Error loading globe:",e),container.innerHTML='<div class="error">Globe failed to load</div>'});